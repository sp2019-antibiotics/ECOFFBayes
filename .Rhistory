orderedZD.Katrin <- orderedZD[n.Katrin,]
n.Tim <- seq(3, nrow(orderedZD), by = 3)
orderedZD.Conny <- orderedZD[n.Conny,]
orderedZD.Tim <- orderedZD[n.Tim,]
################################
library(doParallel)
cl <- makeCluster(detectCores()-2)
getwd()
registerDoParallel(cl)
# test <- foreach(i = 1:100, .verbose=TRUE) %dopar% {
#   cat(i)
# }
#registerDoSNOW(cl)
#progress <- function(n) cat(sprintf("task %d is complete\n", n))
#opts <- list(progress=progress)
clusterEvalQ(cl, sink(paste0("output", Sys.getpid(), ".txt")))
res.list <- foreach(i = 1:100,  .options.snow = opts) %dopar% {
print(paste('Iteration: ', i))
tryCatch({
ECOFFBayesNewTry::TheBayesteApproach(data = orderedZD.Conny[i, ])
}, error = function(err) {
# error handler picks up where error was generated
print(err)
return(NA)
})
}
stopCluster(cl)
stopCluster(cl)
cl <- makeCluster(detectCores()-2)
registerDoParallel(cl)
# test <- foreach(i = 1:100, .verbose=TRUE) %dopar% {
#   cat(i)
# }
#registerDoSNOW(cl)
#progress <- function(n) cat(sprintf("task %d is complete\n", n))
#opts <- list(progress=progress)
clusterEvalQ(cl, sink(paste0("output", Sys.getpid(), ".txt")))
res.list <- foreach(i = 1:100) %dopar% {
print(paste('Iteration: ', i))
tryCatch({
ECOFFBayesNewTry::TheBayesteApproach(data = orderedZD.Conny[i, ])
}, error = function(err) {
# error handler picks up where error was generated
print(err)
return(NA)
})
}
stopCluster(cl)
library(doParallel)
#library(doSNOW)
cl <- makeCluster(detectCores()-2,outfile = "out.txt")
registerDoParallel(cl)
# test <- foreach(i = 1:100, .verbose=TRUE) %dopar% {
#   cat(i)
# }
#registerDoSNOW(cl)
#progress <- function(n) cat(sprintf("task %d is complete\n", n))
#opts <- list(progress=progress)
#clusterEvalQ(cl, sink(paste0("output", Sys.getpid(), ".txt")))
res.list <- foreach(i = 1:300) %dopar% {
print(paste('Iteration: ', i))
tryCatch({
ECOFFBayesNewTry::TheBayesteApproach(data = orderedZD.Conny[i, ])
}, error = function(err) {
# error handler picks up where error was generated
print(err)
return(NA)
})
}
stopCluster(cl)
rm(ZD)
cl
library(doParallel)
#library(doSNOW)
cl <- makeCluster(detectCores()-3,outfile = "out.txt")
registerDoParallel(cl)
# test <- foreach(i = 1:100, .verbose=TRUE) %dopar% {
#   cat(i)
# }
#registerDoSNOW(cl)
#progress <- function(n) cat(sprintf("task %d is complete\n", n))
#opts <- list(progress=progress)
clusterEvalQ(cl, sink(paste0("output", Sys.getpid(), ".txt")))
res.list <- foreach(i = 1:300) %dopar% {
print(paste('Iteration: ', i))
tryCatch({
ECOFFBayesNewTry::TheBayesteApproach(data = orderedZD.Conny[i, ])
}, error = function(err) {
# error handler picks up where error was generated
print(err)
return(NA)
})
}
res.list
res.list[[62]]
res.list[[75]]
saveRDS(res.list,"first300.rds")
readRDS(first300.rds)
readRDS("first300.rds")
stopCluster(cl)
library(doParallel)
#library(doSNOW)
cl <- makeCluster(detectCores()-3)
registerDoParallel(cl)
# test <- foreach(i = 1:100, .verbose=TRUE) %dopar% {
#   cat(i)
# }
#registerDoSNOW(cl)
#progress <- function(n) cat(sprintf("task %d is complete\n", n))
#opts <- list(progress=progress)
clusterEvalQ(cl, sink(paste0("output", Sys.getpid(), ".txt")))
res.list <- foreach(i = 301:480) %dopar% {
print(paste('Iteration: ', i))
tryCatch({
ECOFFBayesNewTry::TheBayesteApproach(data = orderedZD.Conny[i, ])
}, error = function(err) {
# error handler picks up where error was generated
print(err)
return(NA)
})
}
stopCluster(cl)
saveRDS(res.list,"301_480.rds")
res.list[[4]]
res.list[[80]]
481:492
library(doParallel)
#library(doSNOW)
cl <- makeCluster(detectCores()-2)
registerDoParallel(cl)
# test <- foreach(i = 1:100, .verbose=TRUE) %dopar% {
#   cat(i)
# }
#registerDoSNOW(cl)
#progress <- function(n) cat(sprintf("task %d is complete\n", n))
#opts <- list(progress=progress)
clusterEvalQ(cl, sink(paste0("output", Sys.getpid(), ".txt")))
res.list <- foreach(i = 481:492) %dopar% {
print(paste('Iteration: ', i))
tryCatch({
ECOFFBayesNewTry::TheBayesteApproach(data = orderedZD.Conny[i, ])
}, error = function(err) {
# error handler picks up where error was generated
print(err)
return(NA)
})
}
stopCluster(cl)
stopCluster(cl)
#data("ZD", package = "EUCASTData")
library(data.table)
ZD <- fread("EUCASTData/data/ZD.csv")
orderedZD <- ZD[order(Observations), 4:48]
n.Katrin <- seq(1, nrow(orderedZD), by = 3)
n.Conny <- seq(2, nrow(orderedZD), by = 3)
n.Tim <- seq(3, nrow(orderedZD), by = 3)
orderedZD.Katrin <- orderedZD[n.Katrin,]
orderedZD.Conny <- orderedZD[n.Conny,]
orderedZD.Tim <- orderedZD[n.Tim,]
################################
library(doParallel)
cl <- makeCluster(detectCores()-3)
registerDoParallel(cl)
# test <- foreach(i = 1:100, .verbose=TRUE) %dopar% {
#   cat(i)
# }
#registerDoSNOW(cl)
#progress <- function(n) cat(sprintf("task %d is complete\n", n))
#opts <- list(progress=progress)
clusterEvalQ(cl, sink(paste0("output", Sys.getpid(), ".txt")))
res.list <- foreach(i = 481:492) %dopar% {
print(paste('Iteration: ', i))
tryCatch({
ECOFFBayesNewTry::TheBayesteApproach(data = orderedZD.Conny[i, ])
}, error = function(err) {
# error handler picks up where error was generated
print(err)
return(NA)
})
}
stopCluster(cl)
#data("ZD", package = "EUCASTData")
library(data.table)
ZD <- fread("EUCASTData/data/ZD.csv")
ZD
ZD[order(Observations), 4:48]
ZD[order(Observations), 4:49]
# Test
ZDo <- ZD[order(Observations), 4:49]
# Test
ZDo <- ZD[order(Observations), 4:49]
orderedZD <- ZDo[!is.na(ZDo$ECOFF),]
orderedZD
nrow(orderedZD)
library(doParallel)
#library(doSNOW)
cl <- makeCluster(detectCores()-3)
registerDoParallel(cl)
# test <- foreach(i = 1:100, .verbose=TRUE) %dopar% {
#   cat(i)
# }
#registerDoSNOW(cl)
#progress <- function(n) cat(sprintf("task %d is complete\n", n))
#opts <- list(progress=progress)
clusterEvalQ(cl, sink(paste0("output", Sys.getpid(), ".txt")))
res.list <- foreach(i = 1:100) %dopar% {
print(paste('Iteration: ', i))
tryCatch({
ECOFFBayesNewTry::TheBayesteApproach(data = orderedZD.Conny[i, ])
}, error = function(err) {
# error handler picks up where error was generated
print(err)
return(NA)
})
}
stopCluster(cl)
ZDo <- ZD[order(Observations), 4:49]
orderedZD <- ZDo[!is.na(ZDo$ECOFF),]
nrow(orderedZD)
library(doParallel)
#library(doSNOW)
cl <- makeCluster(detectCores()-3)
registerDoParallel(cl)
# test <- foreach(i = 1:100, .verbose=TRUE) %dopar% {
#   cat(i)
# }
#registerDoSNOW(cl)
#progress <- function(n) cat(sprintf("task %d is complete\n", n))
#opts <- list(progress=progress)
clusterEvalQ(cl, sink(paste0("output", Sys.getpid(), ".txt")))
res.list <- foreach(i = 1:100) %dopar% {
print(paste('Iteration: ', i))
tryCatch({
ECOFFBayesNewTry::TheBayesteApproach(data = orderedZD[i, ])
}, error = function(err) {
# error handler picks up where error was generated
print(err)
return(NA)
})
}
stopCluster(cl)
ZDo
ZDo[,-49]
ZDo[,-46]
rowSums(ZDo[,-46])
# Test
ZDo <- ZD[order(Observations), 4:49]
orderedZD <- ZDo[!is.na(ZDo$ECOFF),]
nrow(orderedZD)
library(doParallel)
#library(doSNOW)
cl <- makeCluster(detectCores()-3)
registerDoParallel(cl)
# test <- foreach(i = 1:100, .verbose=TRUE) %dopar% {
#   cat(i)
# }
#registerDoSNOW(cl)
#progress <- function(n) cat(sprintf("task %d is complete\n", n))
#opts <- list(progress=progress)
clusterEvalQ(cl, sink(paste0("output", Sys.getpid(), ".txt")))
res.list <- foreach(i = 1:100) %dopar% {
print(paste('Iteration: ', i))
tryCatch({
ECOFFBayesNewTry::TheBayesteApproach(data = orderedZD[i, ])
}, error = function(err) {
# error handler picks up where error was generated
print(err)
return(NA)
})
}
stopCluster(cl)
#data("ZD", package = "EUCASTData")
library(ECOFFBayesNewTry)
library(data.table)
ZD <- fread("EUCASTData/data/ZD.csv")
# Test
ZD <- ZD[!is.na(ZD$ECOFF),]
orderedZD <- ZD[order(Observations), 4:48]
library(doParallel)
View(orderedZD)
library(doParallel)
cl <- makeCluster(detectCores()-3)
registerDoParallel(cl)
# test <- foreach(i = 1:100, .verbose=TRUE) %dopar% {
#   cat(i)
# }
#registerDoSNOW(cl)
#progress <- function(n) cat(sprintf("task %d is complete\n", n))
#opts <- list(progress=progress)
clusterEvalQ(cl, sink(paste0("output", Sys.getpid(), ".txt")))
res.list <- foreach(i = 1:100) %dopar% {
print(paste('Iteration: ', i))
tryCatch({
ECOFFBayesNewTry::TheBayesteApproach(data = orderedZD[i, ])
}, error = function(err) {
# error handler picks up where error was generated
print(err)
return(NA)
})
}
stopCluster(cl)
stopCluster(cl)
#data("ZD", package = "EUCASTData")
library(ECOFFBayesNewTry)
library(data.table)
ZD <- fread("EUCASTData/data/ZD.csv")
# Test
ZD <- ZD[!is.na(ZD$ECOFF),]
orderedZD <- ZD[order(Observations), 4:48]
library(doParallel)
#library(doSNOW)
cl <- makeCluster(detectCores()-3)
registerDoParallel(cl)
# test <- foreach(i = 1:100, .verbose=TRUE) %dopar% {
#   cat(i)
# }
#registerDoSNOW(cl)
#progress <- function(n) cat(sprintf("task %d is complete\n", n))
#opts <- list(progress=progress)
clusterEvalQ(cl, sink(paste0("output", Sys.getpid(), ".txt")))
res.list <- foreach(i = 1:100) %dopar% {
print(paste('Iteration: ', i))
tryCatch({
ECOFFBayesNewTry::TheBayesteApproach(data = orderedZD[i, ])
}, error = function(err) {
# error handler picks up where error was generated
print(err)
return(NA)
})
}
#data("ZD", package = "EUCASTData")
library(ECOFFBayesNewTry)
library(data.table)
ZD <- fread("EUCASTData/data/ZD.csv")
# Test
ZD <- ZD[!is.na(ZD$ECOFF),]
orderedZD <- ZD[order(Observations), 4:48]
library(doParallel)
cl <- makeCluster(detectCores()-3)
registerDoParallel(cl)
# test <- foreach(i = 1:100, .verbose=TRUE) %dopar% {
#   cat(i)
# }
#registerDoSNOW(cl)
#progress <- function(n) cat(sprintf("task %d is complete\n", n))
#opts <- list(progress=progress)
clusterEvalQ(cl, sink(paste0("output", Sys.getpid(), ".txt")))
res.list <- foreach(i = 1:100) %dopar% {
print(paste('Iteration: ', i))
tryCatch({
ECOFFBayesNewTry::TheBayesteApproach(data = orderedZD[i, ])
}, error = function(err) {
# error handler picks up where error was generated
print(err)
return(NA)
})
}
#data("ZD", package = "EUCASTData")
library(ECOFFBayesNewTry)
library(data.table)
ZD <- fread("EUCASTData/data/ZD.csv")
ZD <- ZD[!is.na(ZD$ECOFF),]
orderedZD <- ZD[order(Observations), 4:48]
library(doParallel)
#library(doSNOW)
cl <- makeCluster(detectCores()-3)
registerDoParallel(cl)
# test <- foreach(i = 1:100, .verbose=TRUE) %dopar% {
#   cat(i)
# }
#registerDoSNOW(cl)
#progress <- function(n) cat(sprintf("task %d is complete\n", n))
#opts <- list(progress=progress)
clusterEvalQ(cl, sink(paste0("output", Sys.getpid(), ".txt")))
res.list <- foreach(i = 1:100) %dopar% {
print(paste('Iteration: ', i))
tryCatch({
ECOFFBayesNewTry::TheBayesteApproach(data = orderedZD[i, ])
}, error = function(err) {
# error handler picks up where error was generated
print(err)
return(NA)
})
}
stopCluster(cl)
saveRDS(res.list, "ONLYECOFF100.rds")
cl <- makeCluster(detectCores()-3)
registerDoParallel(cl)
# test <- foreach(i = 1:100, .verbose=TRUE) %dopar% {
#   cat(i)
# }
#registerDoSNOW(cl)
#progress <- function(n) cat(sprintf("task %d is complete\n", n))
#opts <- list(progress=progress)
clusterEvalQ(cl, sink(paste0("output", Sys.getpid(), ".txt")))
res.list <- foreach(i = 1:100) %dopar% {
print(paste('Iteration: ', i))
print(Sys.time())
tryCatch({
ECOFFBayesNewTry::TheBayesteApproach(data = orderedZD[i, ])
}, error = function(err) {
# error handler picks up where error was generated
print(err)
return(NA)
})
}
stopCluster(cl)
# Test
library(data.table)
ZD <- fread("EUCASTData/data/ZD.csv")
# Test
ZD <- ZD[!is.na(ZD$ECOFF),]
orderedZD <- ZD[order(Observations), 4:48]
n.Katrin <- seq(1, nrow(orderedZD), by = 3)
n.Conny <- seq(2, nrow(orderedZD), by = 3)
n.Tim <- seq(3, nrow(orderedZD), by = 3)
n.Conny
n.Tim
n.Katrin
n.Conny
n.Tim
orderedZD.Katrin <- orderedZD[n.Katrin,]
orderedZD.Conny <- orderedZD[n.Conny,]
orderedZD.Tim <- orderedZD[n.Tim,]
n.Katrin+n.Tim+n.Conny
n.Conny
n.Katrin <- seq(1, nrow(orderedZD), by = 3)
n.Conny <- seq(2, nrow(orderedZD), by = 3)
n.Tim <- seq(3, nrow(orderedZD), by = 3)
orderedZD.Katrin <- orderedZD[n.Katrin,]
orderedZD.Conny <- orderedZD[n.Conny,]
orderedZD.Tim <- orderedZD[n.Tim,]
library(doParallel)
# Test
library(data.table)
ZD <- fread("EUCASTData/data/ZD.csv")
# Test
ZD <- ZD[!is.na(ZD$ECOFF),]
orderedZD <- ZD[order(Observations), 4:48]
n.Katrin <- seq(1, nrow(orderedZD), by = 3)
n.Conny <- seq(2, nrow(orderedZD), by = 3)
n.Tim <- seq(3, nrow(orderedZD), by = 3)
orderedZD.Katrin <- orderedZD[n.Katrin,]
orderedZD.Conny <- orderedZD[n.Conny,]
orderedZD.Tim <- orderedZD[n.Tim,]
library(doParallel)
cl <- makeCluster(detectCores()-3)
registerDoParallel(cl)
library(ECOFFBayesNewTry)
cl <- makeCluster(detectCores()-3)
registerDoParallel(cl)
# test <- foreach(i = 1:100, .verbose=TRUE) %dopar% {
#   cat(i)
# }
#registerDoSNOW(cl)
#progress <- function(n) cat(sprintf("task %d is complete\n", n))
#opts <- list(progress=progress)
clusterEvalQ(cl, sink(paste0("output", Sys.getpid(), ".txt")))
res.list <- foreach(i = 1:123) %dopar% {
print(paste('Iteration: ', i))
print(Sys.time())
tryCatch({
ECOFFBayesNewTry::TheBayesteApproach(data = orderedZD.Conny[i, ])
}, error = function(err) {
# error handler picks up where error was generated
print(err)
return(NA)
})
}
stopCluster(cl)
res.list
saveRDS(res.list, "all_res_CV.rds")
bla <- readRDS("all_res_CV.rds")
save.image("~/Mastersemester2/Projects/Presentation 2/DropBoxCode/newCode/Code/finished.RData")
library(ECOFFBayes)
example("FindECOFF")
library(ECOFFBayes)
#install.packages("devtools")
library(devtools)
#devtools::install_github("klutometis/roxygen")
#install.packages("roxygen2")
library(roxygen2)
setwd("C:/Users/conny/Documents/Mastersemester2/Projects")
#install.packages("devtools")
library(devtools)
#devtools::install_github("klutometis/roxygen")
#install.packages("roxygen2")
library(roxygen2)
create("cats")
setwd("./cats")
devtools::check()
devtools::document()
#install.packages("devtools")
library(devtools)
#devtools::install_github("klutometis/roxygen")
#install.packages("roxygen2")
library(roxygen2)
setwd("C:/Users/conny/Dropbox/Statistical Projects")
setwd("./ECOFFBayes")
install("ECOFFBayes")
setwd("C:/Users/conny/Dropbox/Statistical Projects")
install("ECOFFBayes")
library(ECOFFBayes)
bla <- TheBayesteApproach(c(8,8,8,8,8,8,8,9,10,12,12,12,12,13,13,14,15,16,17,20,20,20,20))
setwd("C:/Users/conny/Dropbox/Statistical Projects")
setwd("./ECOFFBayes")
devtools::check()
library(rjags)
citation(rjags)
citation("rjags")
library(data.table)
ZD <- fread("EUCASTData/data/ZD.csv")
